PLAN

Intro
1. La/Les  structure(s)
  1.1 nos choix techniques
  1.2 difficultés rencontrées
  1.3 améliorations possibles
  1.4 erreurs faites et limites
2.Création Labyrinthe :
 2.1. Génération Aléatoire//Fatma
  2.2. Traitement fichier//Lucie
    2.2.1 lecture dans un fichier
    2.2.2 Sauvegarde dans un fichier
  2.3 Validite du labyrinthe //Lucie
3.Chemin //Morgane
  3.1 Chemin...
4. Affichage //Moe
  4.1 avec chemin/sans chemin a toi de voir si tu fais deux parties disctinsctes moe ;)
5. Main et Makefile//Lucie
  5.1 Main
    5.1.1
    5.1.2
6.Exemples d'executions/manuel utilisateur
  6.1 Test en dur
  6.2 Lecture fichier
  6.3 Aleatoire
    6.3.1 PSeudo
    6.3.2 Totalement
  6.4 chemin
7.Commentaires Globals
Conclu






Intro
Choix techniques /Difficultés rencontrées/erreurs faites/limites des algos


1. La/Les  structure(s)
0.1 nos choix techniques
  Nous avons choisi de créer plusieurs structures. Il y a tout d'abord la structure Maze principale qui comporte les éléments principaux d'un labyrinthe. Mais pour plus de clarté et de facilité, nous avons décidé d'en utiliser d'autres.
  La structure...
  La structure...
  La structure...
Nous avons choisi suite à des divergences d'écritures, d'uiliser un git pour collaborer plus facilement.


2.Création Labyrinthe :

2.1. Génération Aléatoire//Fatma

2.2. Traitement fichier

Nous avons choisi de placer les fonctions traitant les fichiers dans un fichier File.c, qui comporte donc les fonctions lectFic et saveMaze expliquées ci dessous.

2.2.1 lecture dans un fichier
Pour la fonction génération d'un labyrinthe à partir d'un fichier, qui prend en paramètre le nom du fichier, nous testons l'ouverture du fichier donné en paramètre. L'utilisateur a le choix entre un de ses fichiers, et un fichier par défaut (celui de l'énoncé). Si le fichier donné ne s'ouvre pas correctement (valeur de retour égale à NULL), nous affichons l'erreur et renvoyons un labyrinthe dont le nombre de ligne est égale à zéro. De sorte que dans le main, un seul test suffise à déterminer s'il y a un problème d'ouverture.
Si la valeur retournée est différente de NULL, nous scannons les valeurs de la première ligne puis, après avoir alloué dynamiquement un tableau à deux dimensions, nous faisons une double boucle, à partir des valeurs ligne et colonne récupérées précédement. Calloc est préféré à Malloc pour l'allocation, car il initialise l'ensemble à zéro. Il ne reste plus qu'à fermer le fichier, puis à retourner la structure Maze, remplie par les valeurs du fichiers.

2.2.2 Sauvegarde dans un fichier
 
Nous avons choisi également de créer une fonction saveMaze, qui prend en paramètre un nom de fichier (avec extension .txt) et la structure du labyrinthe venant d'etre généré. Que celui ci soit aléatoire, pseudo aléatoire ou formé avec les Piles, cette fonction permet à l'utilisateur d'enregistrer s'il le souhaite le labyrinthe venant d'etre généré, ainsi que le plus court chemin trouvé. De cette facon, l'utilisateur peut sauvegarder les résultats qui l'intéressent.
Cette fonction est programmé comme suit : elle ouvre un nouveau fichier dont le nom est donné en paramètre, le nom a été demandé à l'utilisateur. Elle teste s'il s'ouvre correctement. Si la valeur de retour d'ouverture est différente de NULL, elle écrit les différentes caractéristiques du labyrinthe dans le fichier sous le format donné dans l'énoncé. Puis elle ferme le fichier courant. Cette fonction ne retourne rien.
Notons que parmi les améliorations possibles, nous aurions pu sauvegarder le fichier sans le chemin le plus court, en plus de saugarder celui où il est déjà dessiné.

Il n'y a pas eu de grosses difficultés de rencontrées durant le traitement des fichiers.

Les fonctions vérifiant la validité d'un labyrinthe sont placé dans le fichier Validity.c, comportant les fonctions itob et MazeValid expliquées ci dessous.

2.2.3 Validité et cohérence du labyrinthe

Une des fonctions indispensable était bien sur la fonction testant si les valeurs du labyrinthe étaient cohérentes. Qu'il soit généré par un fichier ou aléatoirement. Meme si le cas d'erreur le plus probable reste celui du fichier, les fonctions aléatoires étant écrite de sorte à éviter ce type d'erreur, nous testons dans le main tous les labyrinthes générés par cette fonction. 
La fonction MazeValid s'appuie sur la fonction itob, qui prend un entier et le décompose en binaire dans un tableau qu'elle retourne. Elle fonctionne avec l'utilisation de divisions euclidienne et donc du modulo. 
MazeValid prend donc en paramètre une structure labyrinthe. Elle teste si les coordonnées de l'entrée et de la sortie sont bien dans le labyrinthe, si l'entrée est positionnée différement de la sortie, et retourne le type d'erreur commise.
Ensuite, Elle teste si les murs correspondent : Si deux cases adjacentes ont bien des murs correspondants, ou le cas échéant, aucun mur. De la sorte, On ne peut pas avoir de mur "simple" entre deux cases. De même elle retourne d'où vient l'erreur s'il y en a une. Après avoir libéré la mémoire allouée avec free, la fonction retourne 1 si le labyrinthe est valide, 0 sinon.

3.Chemin //Morgane
3.1 Chemin...

4. Affichage 
4.1 avec chemin/sans chemin a toi de voir si tu fais deux parties disctinsctes moe ;)

5. Main et Makefile
5.1 Main
Nous avons choisi d'utiliser un switch pour alléger le programme déjà conséquent du main.c. De sorte, une seule vealeur est testée, et cela évite de trop nombreux tests. Nous déclarons les variables locales à la fonction au début. Parmi celles ci la déclaration d'une chaine de caractere pour allouer le nom du fichier de sauvegarde, et l'initialisation du srand pour la génération aléatoire.
Puis nous demandons à l'utilisateur de choisir parmi les quatre générations possible de labyrinthe :

Cas 1 : D'après un fichier donné ou par défaut.

Le fichier par défaut est celui de l'énoncé du projet qui a été joint au mot ENTREE avec un #define de sorte que l'on puisse changer ce fichier plus facilement en ne le modifiant que dans le Maze.h. Après avoir testé si le fichier s'ouvrait, (s'il ne retournait pas une structure dont le nombre de ligne égale zéro) nous vérifions qu'il est valide avec MazeValid, puis on génère le chemin en appelant way_search. Il ne reste plus qu'à afficher le labyrinthe avec dis.

Cas 2 : Génération totalement aléatoire du labyrinthe.

Après avoir confirmé à l'utilisateur que le labyrinthe allait etre généré aléatoirement, on lui demande s'il veut imposer la taille ou s'il préfère que ce soit totalement aléatoire. On le prévient ici que s'il choisit m, soit le nombre de colones supérieur à 35 l'affichage risque d'être faussé car la largeur de l'écran sera atteinte. La taille sera modulo 32767 car cela est la limite du srand. Puis nous lui proposons de sauvegarder le labyrinthe avec saveMaze.

Nous procédons de même pour le cas 3 (génération pseudo aléatoire) et le cas 4 (génération avec Piles pour atteindre toutes les cases depuis l'entrée).

5.2 Makefile
5.2.1 Choix technique
Le principe du Makefile est de découper son code en plusieurs morceaux distincts de façon à le rendre plus compréhensible.
C'est également plus facile de travailler en groupe de la sorte. 
Au vu de l'envergure du projet, et car nous étions au nombre de quatre, il était impératif d'en faire un. 
De sorte, il y a au total un main.c, qui est le main général. Un fichier .h qui est inclus dans tous les autres fichiers .c.  
Et sept fichiers.c distincts, validite.c, fichiers.c, affichage.c, mazerand1.c, mazerand2.c, mazepile.c et waysearch.c.
Tous ces fichiers sont donc liés par le Makefile ce qui permet de distinguer leur utilité et de les modifier plus facilement au besoin.

5.2.2 En pratique
Nous avons décidé en faisant le Makefile, de ne pas alourdir l'écriture avec les différentes commandes possibles.
Nous avons simplement rajouté un "clean" pour supprimer les fichiers .o générés lors de la compilation. Il a été quelque peu compliqué de déterminer s'il y avait dépendence ou non entre les fichiers, et comment traiter le cas du .h. Cependant, après quelques recherches sur internet, étayée par le polycopié distribué en début d'année, cela s'est vite réglé. 
En conclusion, il suffit d'écrire la commande make dans le terminal, puis la commande ./lab pour éxécuter le projet.

6.Exemples d'executions
6.2 Lecture fichier
6.2.1 Résultat d'après le fichier par défaut
6.3 Aleatoire
6.3.1 Totalement Aléatoire
6.3.1.1 Résultat pour une taille aléatoire
6.3.1.2 Résultat pour une taille imposée
6.3.1.3 Résultat enregistré dans un fichier
6.3.2 Pseudo Aléatoire
6.3.2.1 Résultats pour une taille alétoire
6.3.2.2 Résultats pour une taille imposée
6.3.2.3 Résultats enregistré dans un fichier
6.3.3 Avec Piles
6.3.3.1 Résultat pour une taille aléoatoire
6.3.3.2 Résultats pour une taille imposée
6.3.3.3 Résultats enregistré dans un fichier


7. Commentaires globaux/Conclu/Limites trouvées
7.1 Améliorations possibles
Notre projet pourrait etre amélioré de plusieurs facons. A la fois syntaxique, les noms des variables pourraient etre uniformisées et toutes en anglais. Nous pourrions n'utiliser q'une seule structure, mais pour cela il faudrait alourdir la structure Maze principale en lui adjoignant les autres. Et pour finir, Il y a certainement dans notre code des parties redondantes car nous travaillons à plusieurs sur ce projet. Même si nous avons utilisé un git pour tout mettre en commun lors de l'élaboration de ce projet, il y a forcément des améliorations possible, et des croisements.

Conclu
