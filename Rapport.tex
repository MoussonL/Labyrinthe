PLAN

Intro
1. La/Les  structure(s)
  1.1 nos choix techniques
  1.2 difficultés rencontrées
  1.3 améliorations possibles
  1.4 erreurs faites et limites
2.Création Labyrinthe :
  2.1. Traitement fichier//Lucie
    2.1.1 lecture dans un fichier
    2.1.2 Sauvegarde dans un fichier
  2.2. Génération Aléatoire//Fatma
  2.3 Validite du labyrinthe //Lucie
3.Chemin //Morgane
  3.1 Chemin...
4. Affichage //Moe
  4.1 avec chemin/sans chemin a toi de voir si tu fais deux parties disctinsctes moe ;)
5. Main et Makefile//Lucie
  5.1 Main
    5.1.1
    5.1.2
6.Exemples d'executions/manuel utilisateur
  6.1 Test en dur
  6.2 Lecture fichier
  6.3 Aleatoire
    6.3.1 PSeudo
    6.3.2 Totalement
  6.4 chemin
7.Commentaires Globals
Conclu






Intro
Choix techniques /Difficultés rencontrées/erreurs faites/limites des algos


1. La/Les  structure(s)
0.1 nos choix techniques
  Choix de plusieurs structures/pourquoi ?
  
0.2 difficultés rencontrées
  
0.3 erreurs/limites/améliorations possibles
Tout mettre dans la meme struct


2.Création Labyrinthe :

2.1. Génération Aléatoire//Fatma

2.2. Traitement fichier

Nous avons choisi de placer les fonctions traitant les fichiers dans un fichier File.c, qui comporte donc les fonctions lectFic et saveMaze expliquées ci dessous.

2.2.1 lecture dans un fichier
Pour la fonction génération d'un labyrinthe à partir d'un fichier, qui prend en paramètre le nom du fichier, nous testons l'ouverture du fichier donné en paramètre. L'utilisateur a le choix entre un de ses fichiers, et un fichier par défaut (celui de l'énoncé). Si le fichier donné ne s'ouvre pas correctement (valeur de retour égale à NULL), nous affichons l'erreur et renvoyons un labyrithe non valide. De sorte que dans le main, un seul test suffise à déterminer s'il y a un problème d'ouverture.
Si la valeur retournée est différente de NULL, nous scannons les valeurs de la première ligne puis, après avoir alloué dynamiquement un tableau à deux dimensions, nous faisons une double boucle, à partir des valeurs ligne et colonne récupérées précédement. Calloc est préféré à Malloc pour l'allocation, car il initialise l'ensemble à zéro. Il ne reste plus qu'à fermer le fichier, puis à retourner la structure Maze, remplie par les valeurs du fichiers.

2.2.2 Sauvegarde dans un fichier
 
Nous avons choisi également de créer une fonction saveMaze, qui prend en paramètre un nom de fichier (avec extension .txt) et la structure du labyrinthe venant d'etre généré. Que celui ci soit aléatoire, pseudo aléatoire ou formé avec les Piles, cette fonction permet à l'utilisateur d'enregistrer s'il le souhaite le labyrinthe venant d'etre généré, ainsi que le plus court chemin trouvé. De cette facon, l'utilisateur peut sauvegarder les résultats qui l'intéressent.
Cette fonction est programmé comme suit : elle ouvre un nouveau fichier dont le nom est donné en paramètre, le nom a été demandé à l'utilisateur. Elle teste s'il s'ouvre correctement. Si la valeur de retour d'ouverture est différente de NULL, elle écrit les différentes caractéristiques du labyrinthe dans le fichier sous le format donné dans l'énoncé. Puis elle ferme le fichier courant. Cette fonction ne retourne rien.
Notons que parmi les améliorations possibles, nous aurions pu sauvegarder le fichier sans le chemin le plus court, en plus de saugarder celui où il est déjà dessiné.

Les fonctions vérifiant la validité d'un labyrinthe sont placé dans le fichier Validity.c, comportant les fonctions itob et MazeValid expliquées ci dessous.

2.2.3 Validité et cohérence du labyrinthe

Une des fonctions indispensable était bien sur la fonction testant si les valeurs du labyrinthe étaient cohérentes. Qu'il soit généré par un fichier ou aléatoirement. Meme si le cas d'erreur le plus probable reste celui du fichier, les fonctions aléatoires étant écrite de sorte à éviter ce type d'erreur, nosu testons tous les labyrinthes générés par cette fonction. Cette fonction 




3.Chemin //Morgane
3.1 Chemin...

4. Affichage 
4.1 avec chemin/sans chemin a toi de voir si tu fais deux parties disctinsctes moe ;)

5. Main et Makefile
5.1 Main
5.1.1



5.2 Makefile
5.2.1 Pourquoi en faire un
Le principe du Makefile est de découper son code en plusieurs morceaux distincts de façon à le rendre plus compréhensible.
C'est également plus facile de travailler en groupe de la sorte. 
Au vu de l'envergure du projet, et vu le fait que nous étions au nombre de quatre, il était impératif d'en faire un. 
De sorte, il y a au total un main.c, qui est le main général. Un fichier .h qui est inclus dans tous les autres fichiers .c.  
Et sept fichiers.c distincts, validite.c, fichiers.c, affichage.c, mazerand1.c, mazerand2.c, mazepile.c et waysearch.c.
Tous ces fichiers sont donc liés par le Makefile ce qui permet de distinguer leur utilité et de les modifier plus facilement au besoin.

5.2.2 La mise en pratique et les choix techniques
Nous avons décidé en faisant le Makefile, de ne pas alourdir l'écriture avec les différentes commandes possibles.
Nous avons simplement rajouté un "clean" pour supprimer les fichiers .o générés lors de la compilation. 



6.Exemples d'executions
6.1 Test en dur
6.2 Lecture fichier
6.3 Aleatoire
6.3.1 PSeudo
6.3.2 Totalement

7.


.
.
.

Conclu
